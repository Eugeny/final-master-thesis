\section{Drift Detection}
\subsection{Embeddings visualization}
Emeddings of the UNet represent themselves a highly compressed and dense information in comparison to a UNet input - an image itself. Visual information (images) is extremely redundant. Having a value of one pixel it is easy to predict the neighboring ones. UNet however compresses this information into a smaller-dimensions representation. In the architecture of the UNet presented in Figure TODO the size of the embeddings in the bottleneck layer of the network is \textit{256x16x16}, meaning that there are 256 filters were applied to a previous layer and the image was compressed from the resilution of \textit{256x256} to \textit{16x16}, meaning that the image was essitially compressed by the factor of \textit{16x16 = 256}. This compression is done by the \textit{bottleneck} layer.

One might wonder why the information from the small objects like Golgi for example won't be lost with such a compression. The answer for this is a receptive field of the network. Receptive field is the region in the input that produces the feature in the hidden layer (cite https://distill.pub/2019/computing-receptive-fields/ Andre Araujo). In the architecture presented the compression happens due to the \textit{MaxPool} layers with a kernel size of \textit{2x2} with a stride of $2$. After the first \textit{MaxPool} layer one pixel in the embedding will correspond to \textit{2x2=4} pixels of the input. However already after the second layer of compression one pixel in the embedding will contain \textit{4x4 = 16} pixels of the input. This is how the receptive field of the network increases with the compression while the redundancy of the input information decreases.

To visualize the embedding of the UNet one has to first flatten the bottleneck layer into a vector, in the current network implementation the size of such vector will be \textit{655536} which too high dimesional. In order to comprehend the embeddings better one has to first perfom any dimensionaluty reduction algorithm. One of the options is to compress the vector to still a somewhat high-dimentional vector, however with a fewer dimention, or to compress it up to 2D or 3D-dimentional representation, which can be easily comprehendable by humans. Both compessions are presented in this section.

\subsection{Drift detection on the embedding level}