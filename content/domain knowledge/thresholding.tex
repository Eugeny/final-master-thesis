
There are in general two types of thresholding that exist to binarize an image (create its mask): global and local.

\textbf{Global thresholding} is a an algorithm that simply choses one threshold $T$ for the whole histogram of the image. All pixels that are smaller than this threshold $x_{i,j} < T$ are assigned to be of class $0$ (background) and all pixels that are larger than this threshold $x_{i,j} > T$ are assigned to be of class $1$ (foreground). To find a good threshold automatically (at least to some extect) \cite{digital_image_book} proposed the following algorithm:

\begin{algorithm}[H]
  \caption{Global thresholding}
  \begin{algorithmic}
    \item 1. Select an initial estimate for $T$.
    \item 2. Segment the image using T. This will produce 2 groups of pixels $G_1$ (all pixels $x_i > T$) and $G_2$ (all pixels $x_i < T$).  
    \item 3. Computer the average gray values $\mu_1$ and $\mu_2$ for the pixels in  regions $G_1$ and $G_2$.
    \item 4. Compute a new threshold value 
        $T' = \frac{\mu_1 + \mu_2}{2}$
    \item 5. Repeat steps 2-4 until difference in the change of value $T$ is smaller that a predefined parameter.
  \end{algorithmic}
  \label{alg:global-thresholding}
\end{algorithm}

Nevertheless, it is not obvious how to preselect an initial threshold in step 1. There are several options here, however keep in mind that there is also no single best solution among them. For example, when an assumption that the foreground occupies approximately the same area as the background holds, than initial threshold $T$ should be chosen to be an average gray level and etc.

It is implemented in \textit{skimage.filters} and according to the documentation (\cite{global_thresh}) works in the following way: it assumes that the histogram $p = (p_0, \ldots, p_{M})$ of the image is bimodal, meaning that it has two clearly defined peaks (background and foreground). Afetrwards the histogram is iteratively smoothed using a running average of size $k=3$. The points on the histogram are updated with the value $a_k$ from Equation \ref{eq:SMA} until only 2 local maximas ($a_l$ and $a_r$) are left. 
\begin{equation}
    a_k = \frac{1}{k}\sum_{i=n-k + 1}^{n}p_i
\label{eq:SMA}
\end{equation}
Then the threshold is taken as the minimum between the two local maximas:
\begin{equation}
    a_l \leq T \leq a_r
\end{equation}

One clear downside of this approach though is that images which histograms have very unequal peaks or a broad and flat valley will be unsuitable for this method (\cite{thresholding_skimage}).

However, there is another better approach that performs better in such conditions: \textbf{local thresholding}. It is implemented in \textit{skimage.filters} and can be used in the following way:

\begin{lstlisting}
  skimage.filters.local_threshold(img, block_size=7, method='gaussian', offset=0)
\end{lstlisting}

The main idea behind it is the following: instead of selecting one threshold for the whole image (global one), one can select several thresholds for each local region with a predefined size. The comparison between global and local thresholding is presented in Figure \ref{fig:thresholding-bad-conditions}, where (a), (b) denote exteme corruption cases and (c) represents a normal illumination. "The threshold value is the weighted mean for the local neighborhood of a pixel subtracted by a constant" (\cite{digital_image_book}). A stricter mathematical explanation of this algorithm is presented below.

Let $z$ be a random variable that quantifies a gray-level value of the pixel, then the histogram of the image is a probability density function (PDF) $p(z)$. Since we assume that the image contains a background and a foreground, then this PDF is a mixture of two densities $p_1(z)$ and $p_2(z)$ weighted by the relative areas of these two classes (their number of pixels) $P_1$ and $P_2$. Then 

\begin{equation}
    p(z) = P_1 p_1(z) + P_2 p_2(z)
\end{equation}

By assuming Gauassian model for both $p_1(z)$ and $p_2(z)$, one gets a Gaussian Mixture Model (GMM). Since we have assumed that each pixel can be asssigned to either a background of foreground only, $P_1 + P_2 = 1$ must hold. 

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.8\linewidth]{bilder/thresholding-global-min.jpg}
		\caption[Histogram as a probability density function]%
        {Histogram as a probability density function. Taken from \cite{digital_image_book}}\label{fig:gmm}
	\end{center}
\end{figure}

Probability to falsely classify an background pixel as a foreground then is:

\begin{equation}
    E_1(T) = \int_{-\infty}^T{p_2(z) \, dz}
\end{equation}

And probability to falsely classify a foreground pixel as a background then is:

\begin{equation}
    E_2(T) = \int_T^{+\infty}{p_1(z) \, dz}
\end{equation}

The overall error is:

\begin{equation}
    E(T) = P_1E_1(T) + P_2E_2(T)
\end{equation}

Under the assumptions that $p_1(T)$ and $p_2(T)$ are Gaussian distributions, \cite{digital_image_book} show that the optimal solution is:
\begin{equation}
    T = \frac{\mu_1 + \mu_2}{2} + \frac{\sigma^2}{\mu_1 - \mu_2}ln\left(\frac{P_2}{P_1}\right)
\end{equation}

Such threshold search is then applied to all of the subregions of the image with overlaps. Thresholds are calculated only for the regions that contain two clear peaks in their histograms and interpolated to the other pixels from the regions that do not contain them. If the subregions does not contain two peaks, it simply means that there is no foreground or background object on it. 